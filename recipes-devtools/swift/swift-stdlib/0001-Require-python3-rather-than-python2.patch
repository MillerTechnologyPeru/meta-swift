From 29dd948932456c04012861f0bf44abdaa08a8c67 Mon Sep 17 00:00:00 2001
From: Kevin Peizner <kevin.peizner@racepointenergy.com>
Date: Mon, 12 Oct 2020 15:48:01 -0700
Subject: [PATCH] Require python3 rather than python2

---
 CMakeLists.txt                                |  9 +-------
 cmake/modules/StandaloneOverlay.cmake         |  9 +-------
 cmake/modules/SwiftHandleGybSources.cmake     |  4 ++--
 .../public/core/FloatingPointTypes.swift.gyb  |  2 +-
 stdlib/public/core/IntegerTypes.swift.gyb     |  3 +--
 stdlib/public/core/SIMDVectorTypes.swift.gyb  | 22 +++++++++----------
 stdlib/public/core/Tuple.swift.gyb            | 20 ++++++++---------
 test/CMakeLists.txt                           |  6 ++---
 8 files changed, 30 insertions(+), 45 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index df33c456..b9d6d34f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -898,14 +898,7 @@ if(NOT CMAKE_SYSTEM_NAME STREQUAL "Darwin")
   endif()
 endif()
 
-find_package(Python2 COMPONENTS Interpreter REQUIRED)
-find_package(Python3 COMPONENTS Interpreter)
-if(NOT Python3_Interpreter_FOUND)
-  message(WARNING "Python3 not found, using python2 as a fallback")
-  add_executable(Python3::Interpreter IMPORTED)
-  set_target_properties(Python3::Interpreter PROPERTIES
-    IMPORTED_LOCATION ${Python2_EXECUTABLE})
-endif()
+find_package(Python3 COMPONENTS Interpreter REQUIRED)
 
 #
 # Find optional dependencies.
diff --git a/cmake/modules/StandaloneOverlay.cmake b/cmake/modules/StandaloneOverlay.cmake
index 397a8e9f..87d3c18d 100644
--- a/cmake/modules/StandaloneOverlay.cmake
+++ b/cmake/modules/StandaloneOverlay.cmake
@@ -115,14 +115,7 @@ include(SwiftConfigureSDK)
 include(SwiftComponents)
 include(DarwinSDKs)
 
-find_package(Python2 COMPONENTS Interpreter REQUIRED)
-find_package(Python3 COMPONENTS Interpreter)
-if(NOT Python3_Interpreter_FOUND)
-  message(WARNING "Python3 not found, using python2 as a fallback")
-  add_executable(Python3::Interpreter IMPORTED)
-  set_target_properties(Python3::Interpreter PROPERTIES
-    IMPORTED_LOCATION ${Python2_EXECUTABLE})
-endif()
+find_package(Python3 COMPONENTS Interpreter REQUIRED)
 
 # Without this line, installing components is broken. This needs refactoring.
 swift_configure_components()
diff --git a/cmake/modules/SwiftHandleGybSources.cmake b/cmake/modules/SwiftHandleGybSources.cmake
index f8dc984e..b2e60a9d 100644
--- a/cmake/modules/SwiftHandleGybSources.cmake
+++ b/cmake/modules/SwiftHandleGybSources.cmake
@@ -1,7 +1,7 @@
 include(SwiftAddCustomCommandTarget)
 include(SwiftSetIfArchBitness)
 
-find_package(Python2 COMPONENTS Interpreter REQUIRED)
+find_package(Python3 COMPONENTS Interpreter REQUIRED)
 
 # Create a target to process single gyb source with the 'gyb' tool.
 #
@@ -60,7 +60,7 @@ function(handle_gyb_source_single dependency_out_var_name)
       COMMAND
           "${CMAKE_COMMAND}" -E make_directory "${dir}"
       COMMAND
-          "$<TARGET_FILE:Python2::Interpreter>" "${gyb_tool}" ${SWIFT_GYB_FLAGS} ${GYB_SINGLE_FLAGS} -o "${GYB_SINGLE_OUTPUT}.tmp" "${GYB_SINGLE_SOURCE}"
+          "$<TARGET_FILE:Python3::Interpreter>" "${gyb_tool}" ${SWIFT_GYB_FLAGS} ${GYB_SINGLE_FLAGS} -o "${GYB_SINGLE_OUTPUT}.tmp" "${GYB_SINGLE_SOURCE}"
       COMMAND
           "${CMAKE_COMMAND}" -E copy_if_different "${GYB_SINGLE_OUTPUT}.tmp" "${GYB_SINGLE_OUTPUT}"
       COMMAND
diff --git a/stdlib/public/core/FloatingPointTypes.swift.gyb b/stdlib/public/core/FloatingPointTypes.swift.gyb
index a08745e6..64295157 100644
--- a/stdlib/public/core/FloatingPointTypes.swift.gyb
+++ b/stdlib/public/core/FloatingPointTypes.swift.gyb
@@ -981,7 +981,7 @@ extension ${Self}: Hashable {
   %elif bits == 64:
     return Hasher._hash(seed: seed, v.bitPattern)
   %elif bits < 64:
-    return Hasher._hash(seed: seed, bytes: UInt64(v.bitPattern), count: ${bits/8})
+    return Hasher._hash(seed: seed, bytes: UInt64(v.bitPattern), count: ${int(bits/8)})
   %else:
     #error("Unimplemented")
   %end
diff --git a/stdlib/public/core/IntegerTypes.swift.gyb b/stdlib/public/core/IntegerTypes.swift.gyb
index d5fb2b1b..e16b8648 100644
--- a/stdlib/public/core/IntegerTypes.swift.gyb
+++ b/stdlib/public/core/IntegerTypes.swift.gyb
@@ -17,7 +17,6 @@
 from SwiftIntTypes import all_integer_types, int_max_bits, should_define_truncating_bit_pattern_init
 from SwiftFloatingPointTypes import getFtoIBounds
 
-from string import maketrans, capitalize
 from itertools import chain
 
 # Number of bits in the Builtin.Word type
@@ -1658,7 +1657,7 @@ extension ${Self}: Hashable {
     return Hasher._hash(
       seed: seed,
       bytes: UInt64(truncatingIfNeeded: ${U}${Self}(_value)),
-      count: ${bits / 8})
+      count: ${int(bits / 8)})
     % end
   }
 }
diff --git a/stdlib/public/core/SIMDVectorTypes.swift.gyb b/stdlib/public/core/SIMDVectorTypes.swift.gyb
index cdcd42e0..a123d74d 100644
--- a/stdlib/public/core/SIMDVectorTypes.swift.gyb
+++ b/stdlib/public/core/SIMDVectorTypes.swift.gyb
@@ -58,9 +58,9 @@ public struct SIMD${n}<Scalar>: SIMD where Scalar: SIMDScalar {
 
   /// Creates a new vector from the given elements.
   @_transparent
-  public init(${', '.join(['_ v' + str(i) + ': Scalar' for i in range(n)])}) {
+  public init(${', '.join(['_ v' + str(i) + ': Scalar' for i in list(range(n))])}) {
     self.init()
-% for i in range(n):
+% for i in list(range(n)):
     self[${i}] = v${i}
 % end
   }
@@ -69,7 +69,7 @@ public struct SIMD${n}<Scalar>: SIMD where Scalar: SIMDScalar {
   /// Creates a new vector from the given elements.
   ///
   /// - Parameters:
-%  for i in range(n):
+%  for i in list(range(n)):
   ///   - ${'xyzw'[i]}: The ${ordinalPositions[i]} element of the vector.
 %  end
   @_transparent
@@ -77,7 +77,7 @@ public struct SIMD${n}<Scalar>: SIMD where Scalar: SIMDScalar {
     self.init(${', '.join('xyzw'[:n])})
   }
 
-%  for i in range(n):
+%  for i in list(range(n)):
   /// The ${ordinalPositions[i]} element of the vector.
   @_transparent
   public var ${'xyzw'[i]}: Scalar {
@@ -90,17 +90,17 @@ public struct SIMD${n}<Scalar>: SIMD where Scalar: SIMDScalar {
 % if n >= 4:
   /// Creates a new vector from two half-length vectors.
   @_transparent
-  public init(lowHalf: SIMD${n/2}<Scalar>, highHalf: SIMD${n/2}<Scalar>) {
+  public init(lowHalf: SIMD${int(n/2)}<Scalar>, highHalf: SIMD${int(n/2)}<Scalar>) {
     self.init()
     self.lowHalf = lowHalf
     self.highHalf = highHalf
   }
 
-%  for (half,indx) in [('low','i'), ('high',str(n/2)+'+i'), ('even','2*i'), ('odd','2*i+1')]:
+%  for (half,indx) in [('low','i'), ('high',str(int(n/2))+'+i'), ('even','2*i'), ('odd','2*i+1')]:
   /// A half-length vector made up of the ${half} elements of the vector.
-  public var ${half}Half: SIMD${n/2}<Scalar> {
+  public var ${half}Half: SIMD${int(n/2)}<Scalar> {
     @inlinable get {
-      var result = SIMD${n/2}<Scalar>()
+      var result = SIMD${int(n/2)}<Scalar>()
       for i in result.indices { result[i] = self[${indx}] }
       return result
     }
@@ -159,7 +159,7 @@ extension SIMD${n}: CustomDebugStringConvertible {
   public var debugDescription: String {
     return "SIMD${n}<\(Scalar.self)>(${', '.join(map(lambda c:
                        '\\(self['+ str(c) + '])',
-                       xrange(n)))})"
+                       range(n)))})"
   }
 }
 
@@ -212,7 +212,7 @@ extension ${Self}: SIMDScalar {
   public typealias SIMDMaskScalar = ${Mask}
 
 % for n in storagescalarCounts:
-%  bytes = n * self_type.bits / 8
+%  bytes = n * int(self_type.bits / 8)
   /// Storage for a vector of ${spelledNumbers[n]} integers.
   @frozen
   @_alignment(${bytes if bytes <= 16 else 16})
@@ -260,7 +260,7 @@ extension ${Self} : SIMDScalar {
   public typealias SIMDMaskScalar = Int${bits}
 
 % for n in storagescalarCounts:
-%  bytes = n * bits / 8
+%  bytes = n * int(bits / 8)
   /// Storage for a vector of ${spelledNumbers[n]} floating-point values.
   @frozen
   @_alignment(${bytes if bytes <= 16 else 16})
diff --git a/stdlib/public/core/Tuple.swift.gyb b/stdlib/public/core/Tuple.swift.gyb
index 29548c92..289aa539 100644
--- a/stdlib/public/core/Tuple.swift.gyb
+++ b/stdlib/public/core/Tuple.swift.gyb
@@ -105,13 +105,13 @@ public func >=(lhs: (), rhs: ()) -> Bool {
     return true
 }
 
-% for arity in range(2,7):
-%   typeParams = [chr(ord("A") + i) for i in range(arity)]
+% for arity in list(range(2,7)):
+%   typeParams = [chr(ord("A") + i) for i in list(range(arity))]
 %   tupleT = "({})".format(",".join(typeParams))
 %   equatableTypeParams = ", ".join(["{}: Equatable".format(c) for c in typeParams])
 
-%   originalTuple = "(\"a\", {})".format(", ".join(map(str, range(1, arity))))
-%   greaterTuple = "(\"a\", {})".format(", ".join(map(str, range(1, arity - 1) + [arity])))
+%   originalTuple = "(\"a\", {})".format(", ".join(map(str, list(range(1, arity)))))
+%   greaterTuple = "(\"a\", {})".format(", ".join(map(str, list(range(1, arity - 1)) + [arity])))
 
 /// Returns a Boolean value indicating whether the corresponding components of
 /// two tuples are equal.
@@ -136,9 +136,9 @@ public func >=(lhs: (), rhs: ()) -> Bool {
 public func == <${equatableTypeParams}>(lhs: ${tupleT}, rhs: ${tupleT}) -> Bool {
   guard lhs.0 == rhs.0 else { return false }
   /*tail*/ return (
-    ${", ".join("lhs.{}".format(i) for i in range(1, arity))}
+    ${", ".join("lhs.{}".format(i) for i in list(range(1, arity)))}
   ) == (
-    ${", ".join("rhs.{}".format(i) for i in range(1, arity))}
+    ${", ".join("rhs.{}".format(i) for i in list(range(1, arity)))}
   )
 }
 
@@ -165,9 +165,9 @@ public func == <${equatableTypeParams}>(lhs: ${tupleT}, rhs: ${tupleT}) -> Bool
 public func != <${equatableTypeParams}>(lhs: ${tupleT}, rhs: ${tupleT}) -> Bool {
   guard lhs.0 == rhs.0 else { return true }
   /*tail*/ return (
-    ${", ".join("lhs.{}".format(i) for i in range(1, arity))}
+    ${", ".join("lhs.{}".format(i) for i in list(range(1, arity)))}
   ) != (
-    ${", ".join("rhs.{}".format(i) for i in range(1, arity))}
+    ${", ".join("rhs.{}".format(i) for i in list(range(1, arity)))}
   )
 }
 
@@ -188,9 +188,9 @@ public func != <${equatableTypeParams}>(lhs: ${tupleT}, rhs: ${tupleT}) -> Bool
 public func ${op} <${comparableTypeParams}>(lhs: ${tupleT}, rhs: ${tupleT}) -> Bool {
   if lhs.0 != rhs.0 { return lhs.0 ${op} rhs.0 }
   /*tail*/ return (
-    ${", ".join("lhs.{}".format(i) for i in range(1, arity))}
+    ${", ".join("lhs.{}".format(i) for i in list(range(1, arity)))}
   ) ${op} (
-    ${", ".join("rhs.{}".format(i) for i in range(1, arity))}
+    ${", ".join("rhs.{}".format(i) for i in list(range(1, arity)))}
   )
 }
 %   end
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index b68a15e9..10daf36d 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -345,7 +345,7 @@ _Block_release(void) { }\n")
       endif()
 
       execute_process(COMMAND
-          $<TARGET_FILE:Python2::Interpreter> "-c" "import psutil"
+          $<TARGET_FILE:Python3::Interpreter> "-c" "import psutil"
           RESULT_VARIABLE python_psutil_status
           TIMEOUT 1 # second
           ERROR_QUIET)
@@ -405,7 +405,7 @@ _Block_release(void) { }\n")
             ${command_upload_swift_reflection_test}
             ${command_clean_test_results_dir}
             COMMAND
-              $<TARGET_FILE:Python2::Interpreter> "${LIT}"
+              $<TARGET_FILE:Python3::Interpreter> "${LIT}"
               ${LIT_ARGS}
               "--param" "swift_test_subset=${test_subset}"
               "--param" "swift_test_mode=${test_mode}"
@@ -424,7 +424,7 @@ _Block_release(void) { }\n")
             ${command_upload_swift_reflection_test}
             ${command_clean_test_results_dir}
             COMMAND
-              $<TARGET_FILE:Python2::Interpreter> "${LIT}"
+              $<TARGET_FILE:Python3::Interpreter> "${LIT}"
               ${LIT_ARGS}
               "--param" "swift_test_subset=${test_subset}"
               "--param" "swift_test_mode=${test_mode}"
